==== /src/app.ml ====
-12,60 +12,77
  }
  |}]
  
  let rows = 20
  let cols = 20
  
  let get_keydown_key evt =
    evt##.code
    |> Js_of_ocaml.Js.Optdef.to_option
    |> Option.value_exn
    |> Js_of_ocaml.Js.to_string
  ;;
  
  let component =
    let open Bonsai.Let_syntax in
    (* State *)
-|  let%sub player, player_inject = Player.computation ~rows ~cols ~color:"green" in
+|  let%sub player1, player1_inject = Player.computation ~rows ~cols ~color:"green" in
-|  let%sub apple, apple_inject = Apple.computation ~rows ~cols in
+|  let%sub player2, player2_inject = Player.computation ~rows ~cols ~color:"blue" in
+|  let%sub apple, apple_inject = Apple.computation ~rows ~cols in
+|  let%sub game_elements =
+|    let%arr player1 = player1
+|    and player2 = player2
+|    and apple = apple
+|    and apple_inject = apple_inject in
+|    { Game_elements.snakes = Player.snakes [ player1; player2 ]
+|    ; apples = [ apple, apple_inject ]
+|    }
+|  in
    (* Tick logic *)
    let%sub () =
      let%sub clock_effect =
-|      let%arr player_inject = player_inject
-|      and apple = apple
-|      and apple_inject = apple_inject in
-|      player_inject (Move (apple, apple_inject))
+|      let%arr player1_inject = player1_inject
+|      and player2_inject = player2_inject
+|      and game_elements = game_elements in
+|      Effect.Many
+|        [ player1_inject (Move game_elements); player2_inject (Move game_elements) ]
      in
      Bonsai.Clock.every [%here] (Time_ns.Span.of_sec 0.25) clock_effect
    in
    (* Reset logic *)
    let%sub reset_action =
-|    let%arr player_inject = player_inject
-|    and apple_inject = apple_inject
-|    and player = player
-|    and apple = apple in
+|    let%arr player1_inject = player1_inject
+|    and player2_inject = player2_inject
+|    and apple_inject = apple_inject
+|    and game_elements = game_elements in
-|    let invalid_pos = Player.snake_pos player @ Apple.list_of_t apple in
+|    let invalid_pos = Game_elements.occupied_pos game_elements in
-|    Effect.Many [ player_inject Restart; apple_inject (Spawn invalid_pos) ]
+|    Effect.Many
+|      [ player1_inject Restart; player2_inject Restart; apple_inject (Spawn invalid_pos) ]
    in
    (* View component *)
-|  let%sub board = Board.component ~rows ~cols player apple in
+|  let%sub board = Board.component ~rows ~cols player1 player2 apple in
    let%arr board = board
-|  and player_inject = player_inject
+|  and player1_inject = player1_inject
+|  and player2_inject = player2_inject
    and reset_action = reset_action in
    let on_keydown evt =
      match get_keydown_key evt with
-|    | "KeyW" -> player_inject (Change_direction Up)
+|    | "KeyW" -> player1_inject (Change_direction Up)
-|    | "KeyS" -> player_inject (Change_direction Down)
+|    | "KeyS" -> player1_inject (Change_direction Down)
-|    | "KeyA" -> player_inject (Change_direction Left)
+|    | "KeyA" -> player1_inject (Change_direction Left)
-|    | "KeyD" -> player_inject (Change_direction Right)
+|    | "KeyD" -> player1_inject (Change_direction Right)
+|    | "ArrowUp" -> player2_inject (Change_direction Up)
+|    | "ArrowDown" -> player2_inject (Change_direction Down)
+|    | "ArrowLeft" -> player2_inject (Change_direction Left)
+|    | "ArrowRight" -> player2_inject (Change_direction Right)
      | _ -> Effect.Ignore
    in
    Vdom.(
      Node.div
        ~attr:
          (Attr.many
             [ Attr.on_keydown on_keydown
             ; Attr.on_click (fun _ -> reset_action)
             ; Attr.class_ Style.app
             ])
        [ board ])
  ;;

==== /src/board.ml ====
-64,44 +64,44
      | Some x -> x
      | None -> "white"
  ;;
  
  let set_style_property key value =
    let open Js_of_ocaml in
    let priority = Js.undefined in
    let res =
      Dom_html.document##.documentElement##.style##setProperty
        (Js.string key)
        (Js.string value)
        priority
    in
    ignore res
  ;;
  
-|let component ~rows ~cols player apple =
+|let component ~rows ~cols player1 player2 apple =
    let open Bonsai.Let_syntax in
    (* TODO: use `Attr.css_var` instead. *)
    let on_activate =
      Ui_effect.of_sync_fun
        (fun () ->
          set_style_property "--grid-rows" (Int.to_string rows);
          set_style_property "--grid-cols" (Int.to_string cols))
        ()
      |> Value.return
    in
    let%sub () = Bonsai.Edge.lifecycle ~on_activate () in
-|  let%arr player = player
+|  let%arr player1 = player1
+|  and player2 = player2
-|  and apple = apple in
-|  let cell_bg_driver =
-|    match player with
-|    | Player.Not_started -> merge_cell_bg_drivers ~snakes:[] ~apples:[]
-|    | Playing data | Game_over (data, _) ->
-|      merge_cell_bg_drivers ~snakes:[ data.snake ] ~apples:[ apple ]
-|  in
+|  and apple = apple in
+|  let snakes = Player.snakes [ player1; player2 ] in
+|  let cell_bg_driver = merge_cell_bg_drivers ~snakes ~apples:[ apple ] in
    Vdom.(
      Node.div
        [ Node.h1 [ Node.text "Snake Game" ]
        ; view_instructions
-|      ; view_score_status ~label:"Results" player
+|      ; Node.div
+|          [ view_score_status ~label:"Player 1" player1
+|          ; view_score_status ~label:"Player 2" player2
+|          ]
        ; view_board rows cols cell_bg_driver
        ])
  ;;

==== /src/board.mli ====
-1,9 +1,10
  open! Core
  open! Bonsai_web
  
  val component
    :  rows:int
    -> cols:int
    -> Player.t Value.t
+|  -> Player.t Value.t
    -> Apple.t Value.t
    -> Vdom.Node.t Computation.t

==== /src/game_elements.ml ====
-1,0 +1,16
+|open! Core
+|open Bonsai
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : (Apple.t * (Apple.Action.t -> unit Effect.t)) list
+|  }
+|[@@deriving sexp]
+|
+|let occupied_pos t =
+|  let snake_pos = t.snakes |> List.map ~f:Snake.list_of_t |> List.join in
+|  let apple_pos =
+|    t.apples |> List.map ~f:Tuple2.get1 |> List.map ~f:Apple.list_of_t |> List.join
+|  in
+|  snake_pos @ apple_pos
+|;;

==== /src/game_elements.mli ====
-1,0 +1,10
+|open! Core
+|open Bonsai
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : (Apple.t * (Apple.Action.t -> unit Effect.t)) list
+|  }
+|[@@deriving sexp]
+|
+|val occupied_pos : t -> Position.t list

==== /src/player.ml ====
-19,70 +19,82
    end
  
    type t =
      | Not_started
      | Playing of Data.t
      | Game_over of (Data.t * End_reason.t)
    [@@deriving sexp, equal, variants]
  end
  
  include Model
  
  let snake_pos = function
    | Playing data | Game_over (data, _) -> Snake.list_of_t data.snake
    | Not_started -> []
  ;;
  
+|let snakes ps =
+|  List.fold ps ~init:[] ~f:(fun snakes -> function
+|    | Playing data | Game_over (data, _) -> data.snake :: snakes
+|    | Not_started -> snakes)
+|;;
+|
  module Action = struct
    type t =
      | Restart
-|    | Move of (Apple.t * (Apple.Action.t -> unit Effect.t))
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
    [@@deriving sexp]
  end
  
  let ate_apple_score = 1
  
  let apply_action
    ~rows
    ~cols
    ~color
    ~inject:_
    ~schedule_event
    (model : Model.t)
    (action : Action.t)
    =
    match action, model with
    | Restart, _ ->
      let snake = Snake.spawn_random ~rows ~cols:(cols / 2) ~color in
      Playing { score = 0; snake; direction = Right }
-|  | Move (apple, apple_inject), Playing data ->
+|  | Move game_elements, Playing data ->
      let snake = Snake.move data.snake data.direction in
      if Snake.is_eatting_self snake
      then Game_over (data, Ate_self)
      else if Snake.is_out_of_bounds ~rows ~cols snake
      then Game_over (data, Out_of_bounds)
-|    else if Apple.is_eatten apple snake
-|    then (
+|    else (
+|      let num_apples_eatten =
+|        let apples_eatten =
+|          game_elements.apples
+|          |> List.filter ~f:(fun (apple, _) -> Apple.is_eatten apple snake)
+|        in
-|      let invalid_pos = Snake.list_of_t snake @ Apple.list_of_t apple in
-|      let () = schedule_event (apple_inject (Apple.Action.Eatten invalid_pos)) in
+|        let invalid_pos = Game_elements.occupied_pos game_elements in
+|        List.iter apples_eatten ~f:(fun (_, apple_inject) ->
+|          schedule_event (apple_inject (Eatten invalid_pos)));
+|        List.length apples_eatten
+|      in
        Playing
          { direction = data.direction
-|        ; snake = Snake.grow_eventually ~by:1 snake
+|        ; snake = Snake.grow_eventually ~by:num_apples_eatten snake
-|        ; score = data.score + ate_apple_score
+|        ; score = data.score + (num_apples_eatten * ate_apple_score)
          })
-|    else Playing { direction = data.direction; snake; score = data.score }
    | Change_direction dir, Playing data -> Playing { data with direction = dir }
    | Move _, Not_started
    | Move _, Game_over _
    | Change_direction _, Not_started
    | Change_direction _, Game_over _ -> model
  ;;
  
  let computation ~rows ~cols ~color =
    Bonsai.state_machine0
      [%here]
      (module Model)
      (module Action)
      ~default_model:Not_started
      ~apply_action:(apply_action ~rows ~cols ~color)
  ;;

==== /src/player.mli ====
-10,30 +10,36
  
  module Data : sig
    type t =
      { score : int
      ; snake : Snake.t
      ; direction : Direction.t
      }
    [@@deriving sexp, equal, fields]
  end
  
  type t =
    | Not_started
    | Playing of Data.t
    | Game_over of (Data.t * End_reason.t)
  [@@deriving sexp, equal, variants]
  
-|val snake_pos : t -> Position.t list
+|(** [snake_pos t] returns a list of positions occupied by the player's snake.
+|    If the game hasn't started, this will return an empty list. *)
+|val snake_pos : t -> Position.t list
+|
+|(** [snakes ps] returns a list of snakes for each player who's status isn't
+|    [Not_started]. *)
+|val snakes : t list -> Snake.t list
  
  module Action : sig
    type t =
      | Restart
-|    | Move of (Apple.t * (Apple.Action.t -> unit Effect.t))
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
  end
  
  val computation
    :  rows:int
    -> cols:int
    -> color:string
    -> (t * (Action.t -> unit Effect.t)) Computation.t
