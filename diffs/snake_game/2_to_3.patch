==== /src/app.ml ====
-9,67 +9,120
  .app {
    width: 100%;
    height: 100%;
  }
  |}]
  
  let rows = 20
  let cols = 20
  
  let get_keydown_key evt =
    evt##.code
    |> Js_of_ocaml.Js.Optdef.to_option
    |> Option.value_exn
    |> Js_of_ocaml.Js.to_string
  ;;
  
+|let chain_scheduler
+|  : type a. a Value.t -> ((a -> unit Ui_effect.t) list -> unit Ui_effect.t) Computation.t
+|  =
+| fun input ->
+|  let module Action = struct
+|    type t = Run of (a -> unit Effect.t) list [@@deriving sexp]
+|  end
+|  in
+|  let apply_action ~inject ~schedule_event input _model (Action.Run effect_fns) =
+|    match effect_fns with
+|    | effect_fn :: dependents ->
+|      schedule_event (Effect.Many [ effect_fn input; inject (Action.Run dependents) ])
+|    | [] -> ()
+|  in
+|  let open Bonsai.Let_syntax in
+|  let%sub (), inject =
+|    Bonsai.state_machine1
+|      [%here]
+|      (module Unit)
+|      (module Action)
+|      ~default_model:()
+|      ~apply_action
+|      input
+|  in
+|  let%arr inject = inject in
+|  fun effects -> inject (Action.Run effects)
+|;;
+|
  let component =
    let open Bonsai.Let_syntax in
    (* State *)
-|  let%sub player, player_inject = Player_state.computation ~rows ~cols ~color:"green" in
+|  let%sub player1, player1_inject = Player_state.computation ~rows ~cols ~color:"green" in
-|  let%sub apple, apple_inject = Apple_state.computation ~rows ~cols in
+|  let%sub player2, player2_inject = Player_state.computation ~rows ~cols ~color:"blue" in
+|  let%sub apple1, apple1_inject = Apple_state.computation ~rows ~cols in
+|  let%sub apple2, apple2_inject = Apple_state.computation ~rows ~cols in
+|  let%sub game_elements =
+|    let%arr player1 = player1
+|    and player2 = player2
+|    and apple1 = apple1
+|    and apple2 = apple2 in
+|    { Game_elements.snakes = Player_state.Model.snakes [ player1; player2 ]
+|    ; apples = Apple_state.Model.apples [ apple1; apple2 ]
+|    }
+|  in
+|  let%sub scheduler = chain_scheduler game_elements in
    (* Tick logic *)
    let%sub () =
      let%sub clock_effect =
-|      let%arr player_inject = player_inject
-|      and apple = apple
-|      and apple_inject = apple_inject in
-|      match apple with
-|      | Playing apple -> player_inject (Move (apple, apple_inject))
-|      | Not_started -> Effect.Ignore
+|      let%arr player1_inject = player1_inject
+|      and player2_inject = player2_inject
+|      and apple1_inject = apple1_inject
+|      and apple2_inject = apple2_inject
+|      and scheduler = scheduler in
+|      scheduler
+|        [ (fun g -> player1_inject (Move g))
+|        ; (fun g -> player2_inject (Move g))
+|        ; (fun g -> apple1_inject (Tick g))
+|        ; (fun g -> apple2_inject (Tick g))
+|        ]
      in
      Bonsai.Clock.every [%here] (Time_ns.Span.of_sec 0.25) clock_effect
    in
    (* Reset logic *)
    let%sub reset_action =
-|    let%arr player_inject = player_inject
-|    and apple_inject = apple_inject
-|    and player = player
-|    and apple = apple in
-|    let invalid_pos =
-|      Player_state.Model.snake_pos player @ Apple_state.Model.apple_pos apple
-|    in
-|    Effect.Many [ player_inject Restart; apple_inject (Spawn invalid_pos) ]
+|    let%arr player1_inject = player1_inject
+|    and player2_inject = player2_inject
+|    and apple1_inject = apple1_inject
+|    and apple2_inject = apple2_inject
+|    and scheduler = scheduler in
+|    scheduler
+|      [ (fun g -> player1_inject (Restart g))
+|      ; (fun g -> player2_inject (Restart g))
+|      ; (fun g -> apple1_inject (Spawn g))
+|      ; (fun g -> apple2_inject (Spawn g))
+|      ]
    in
    (* View component *)
-|  let%sub board = Board.component ~rows ~cols player apple in
+|  let%sub board = Board.component ~rows ~cols player1 player2 game_elements in
    let%arr board = board
-|  and player_inject = player_inject
+|  and player1_inject = player1_inject
+|  and player2_inject = player2_inject
    and reset_action = reset_action in
    let on_keydown evt =
      match get_keydown_key evt with
-|    | "KeyW" -> player_inject (Change_direction Up)
+|    | "KeyW" -> player1_inject (Change_direction Up)
-|    | "KeyS" -> player_inject (Change_direction Down)
+|    | "KeyS" -> player1_inject (Change_direction Down)
-|    | "KeyA" -> player_inject (Change_direction Left)
+|    | "KeyA" -> player1_inject (Change_direction Left)
-|    | "KeyD" -> player_inject (Change_direction Right)
+|    | "KeyD" -> player1_inject (Change_direction Right)
+|    | "ArrowUp" -> player2_inject (Change_direction Up)
+|    | "ArrowDown" -> player2_inject (Change_direction Down)
+|    | "ArrowLeft" -> player2_inject (Change_direction Left)
+|    | "ArrowRight" -> player2_inject (Change_direction Right)
      | _ -> Effect.Ignore
    in
    Vdom.(
      Node.div
        ~attr:
          (Attr.many
             [ Attr.on_keydown on_keydown
             ; Attr.on_click (fun _ -> reset_action)
             ; Attr.class_ Style.app
             ])
        [ board ])
  ;;

==== /src/apple_state.ml ====
-1,37 +1,46
  open! Core
  open! Bonsai_web
  
  module Model = struct
    type t =
      | Not_started
      | Playing of Apple.t
    [@@deriving sexp, equal]
  
-|  let apple_pos t =
-|    match t with
-|    | Playing a -> Apple.list_of_t a
+|  let apples states =
+|    List.fold states ~init:[] ~f:(fun apples -> function
+|      | Playing apple -> apple :: apples
-|    | Not_started -> []
+|      | Not_started -> apples)
    ;;
  end
  
  module Action = struct
    type t =
-|    | Spawn of Position.t list
-|    | Eatten of Position.t list
+|    | Spawn of Game_elements.t
+|    | Tick of Game_elements.t
    [@@deriving sexp]
  end
  
-|let apply_action ~rows ~cols ~inject:_ ~schedule_event:_ _model action =
+|let spawn ~rows ~cols game_elements =
+|  let invalid_pos = Game_elements.occupied_pos game_elements in
+|  Model.Playing (Apple.spawn_random_exn ~rows ~cols ~invalid_pos)
+|;;
+|
+|let apply_action ~rows ~cols ~inject:_ ~schedule_event:_ model action =
-|  match action with
+|  match action, model with
-|  | Action.Eatten invalid_pos | Spawn invalid_pos ->
-|    Model.Playing (Apple.spawn_random_exn ~rows ~cols ~invalid_pos)
+|  | Action.Spawn game_elements, _ -> spawn ~rows ~cols game_elements
+|  | Tick game_elements, Model.Playing apple ->
+|    if List.exists game_elements.snakes ~f:(fun s -> Snake.is_eatting_apple s apple)
+|    then spawn ~rows ~cols game_elements
+|    else model
+|  | Tick _, Model.Not_started -> model
  ;;
  
  let computation ~rows ~cols =
    Bonsai.state_machine0
      [%here]
      (module Model)
      (module Action)
      ~default_model:Not_started
      ~apply_action:(apply_action ~rows ~cols)
  ;;

==== /src/apple_state.mli ====
-1,23 +1,27
  open! Core
  open! Bonsai_web
  
  module Model : sig
    type t =
      | Not_started
      | Playing of Apple.t
    [@@deriving sexp, equal]
  
-|  val apple_pos : t -> Position.t list
+|  (** [apples states] returns a list of [Apple.t]s  for each apple
+|    who's status isn't [Not_started].
+|    Intended to be used in the assembly of [Game_elements.t],
+|    but can't be located there to avoid circular dependencies. *)
+|  val apples : t list -> Apple.t list
  end
  
  module Action : sig
    type t =
-|    | Spawn of Position.t list
-|    | Eatten of Position.t list
+|    | Spawn of Game_elements.t
+|    | Tick of Game_elements.t
    [@@deriving sexp]
  end
  
  val computation
    :  rows:int
    -> cols:int
    -> (Model.t * (Action.t -> unit Effect.t)) Computation.t

==== /src/board.ml ====
-64,45 +64,45
      | Some x -> x
      | None -> "white"
  ;;
  
  let set_style_property key value =
    let open Js_of_ocaml in
    let priority = Js.undefined in
    let res =
      Dom_html.document##.documentElement##.style##setProperty
        (Js.string key)
        (Js.string value)
        priority
    in
    ignore res
  ;;
  
-|let component ~rows ~cols player apple =
+|let component ~rows ~cols player1 player2 (game_elements : Game_elements.t Value.t) =
    let open Bonsai.Let_syntax in
    (* TODO: use `Attr.css_var` instead. *)
    let on_activate =
      Ui_effect.of_sync_fun
        (fun () ->
          set_style_property "--grid-rows" (Int.to_string rows);
          set_style_property "--grid-cols" (Int.to_string cols))
        ()
      |> Value.return
    in
    let%sub () = Bonsai.Edge.lifecycle ~on_activate () in
-|  let%arr player = player
-|  and apple = apple in
+|  let%arr player1 = player1
+|  and player2 = player2
+|  and game_elements = game_elements in
-|  let cell_bg_driver =
-|    match player, apple with
-|    | Player_state.Model.Not_started, _ | _, Apple_state.Model.Not_started ->
+|  let cell_bg_driver =
-|      merge_cell_bg_drivers ~snakes:[] ~apples:[]
-|    | Playing data, Playing apple | Game_over (data, _), Playing apple ->
-|      merge_cell_bg_drivers ~snakes:[ data.snake ] ~apples:[ apple ]
+|    merge_cell_bg_drivers ~snakes:game_elements.snakes ~apples:game_elements.apples
    in
    Vdom.(
      Node.div
        [ Node.h1 [ Node.text "Snake Game" ]
        ; view_instructions
-|      ; view_score_status ~label:"Results" player
+|      ; Node.div
+|          [ view_score_status ~label:"Player 1" player1
+|          ; view_score_status ~label:"Player 2" player2
+|          ]
        ; view_board rows cols cell_bg_driver
        ])
  ;;

==== /src/board.mli ====
-1,9 +1,10
  open! Core
  open! Bonsai_web
  
  val component
    :  rows:int
    -> cols:int
    -> Player_state.Model.t Value.t
-|  -> Apple_state.Model.t Value.t
+|  -> Player_state.Model.t Value.t
+|  -> Game_elements.t Value.t
    -> Vdom.Node.t Computation.t

==== /src/game_elements.ml ====
-1,0 +1,13
+|open! Core
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : Apple.t list
+|  }
+|[@@deriving sexp]
+|
+|let occupied_pos t =
+|  let snake_pos = t.snakes |> List.map ~f:Snake.list_of_t |> List.join in
+|  let apple_pos = t.apples |> List.map ~f:Apple.list_of_t |> List.join in
+|  snake_pos @ apple_pos
+|;;

==== /src/game_elements.mli ====
-1,0 +1,9
+|open! Core
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : Apple.t list
+|  }
+|[@@deriving sexp]
+|
+|val occupied_pos : t -> Position.t list

==== /src/player_state.ml ====
-11,76 +11,79
  
    module Data = struct
      type t =
        { score : int
        ; snake : Snake.t
        ; direction : Direction.t
        }
      [@@deriving sexp, equal, fields]
    end
  
    type t =
      | Not_started
      | Playing of Data.t
      | Game_over of (Data.t * End_reason.t)
    [@@deriving sexp, equal, variants]
  
-|  let snake_pos = function
+|  let snakes states =
+|    List.fold states ~init:[] ~f:(fun snakes -> function
-|    | Playing data | Game_over (data, _) -> Snake.list_of_t data.snake
+|      | Playing data | Game_over (data, _) -> data.snake :: snakes
-|    | Not_started -> []
+|      | Not_started -> snakes)
    ;;
  end
  
  module Action = struct
    type t =
-|    | Restart
-|    | Move of (Apple.t * (Apple_state.Action.t -> unit Effect.t))
+|    | Restart of Game_elements.t
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
    [@@deriving sexp]
  end
  
  let ate_apple_score = 1
  
  let apply_action
    ~rows
    ~cols
    ~color
    ~inject:_
-|  ~schedule_event
+|  ~schedule_event:_
    (model : Model.t)
    (action : Action.t)
    =
    match action, model with
-|  | Restart, _ ->
-|    let snake = Snake.spawn_random_exn ~rows ~cols:(cols / 2) ~color in
+|  | Restart game_elements, _ ->
+|    let invalid_pos = Game_elements.occupied_pos game_elements in
+|    let snake = Snake.spawn_random_exn ~rows ~cols:(cols / 2) ~color ~invalid_pos in
      Model.Playing { score = 0; snake; direction = Right }
-|  | Move (apple, apple_inject), Playing data ->
+|  | Move game_elements, Playing data ->
      let snake = Snake.move data.snake data.direction in
      if Snake.is_eatting_self snake
      then Game_over (data, Ate_self)
      else if Snake.is_out_of_bounds ~rows ~cols snake
      then Game_over (data, Out_of_bounds)
-|    else if Snake.is_eatting_apple snake apple
-|    then (
-|      let invalid_pos = Snake.list_of_t snake @ Apple.list_of_t apple in
-|      let () = schedule_event (apple_inject (Apple_state.Action.Eatten invalid_pos)) in
+|    else (
+|      let num_apples_eatten =
+|        game_elements.apples
+|        |> List.filter ~f:(Snake.is_eatting_apple snake)
+|        |> List.length
+|      in
        Playing
          { direction = data.direction
-|        ; snake = Snake.grow_eventually ~by:1 snake
+|        ; snake = Snake.grow_eventually ~by:num_apples_eatten snake
-|        ; score = data.score + ate_apple_score
+|        ; score = data.score + (num_apples_eatten * ate_apple_score)
          })
-|    else Playing { direction = data.direction; snake; score = data.score }
    | Change_direction dir, Playing data -> Playing { data with direction = dir }
    | Move _, Not_started
    | Move _, Game_over _
    | Change_direction _, Not_started
    | Change_direction _, Game_over _ -> model
  ;;
  
  let computation ~rows ~cols ~color =
    Bonsai.state_machine0
      [%here]
      (module Model)
      (module Action)
      ~default_model:Not_started
      ~apply_action:(apply_action ~rows ~cols ~color)
  ;;

==== /src/player_state.mli ====
-11,31 +11,34
  
    module Data : sig
      type t =
        { score : int
        ; snake : Snake.t
        ; direction : Direction.t
        }
      [@@deriving sexp, equal, fields]
    end
  
    type t =
      | Not_started
      | Playing of Data.t
      | Game_over of (Data.t * End_reason.t)
    [@@deriving sexp, equal, variants]
  
-|  val snake_pos : t -> Position.t list
+|  (** [snakes ps] returns a list of snakes for each player who's status isn't
+|      [Not_started]. Intended to be used in the assembly of [Game_elements.t],
+|      but can't be located there to avoid circular dependencies. *)
+|  val snakes : t list -> Snake.t list
  end
  
  module Action : sig
    type t =
-|    | Restart
-|    | Move of (Apple.t * (Apple_state.Action.t -> unit Effect.t))
+|    | Restart of Game_elements.t
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
  end
  
  val computation
    :  rows:int
    -> cols:int
    -> color:string
    -> (Model.t * (Action.t -> unit Effect.t)) Computation.t

==== /src/snake.ml ====
-1,29 +1,29
  open! Core
  
  type t =
    { pos : Position.t list
    ; left_to_grow : int
    ; color : string
    }
  [@@deriving sexp, equal]
  
  let list_of_t s = s.pos
  
-|let spawn_random_exn ~rows ~cols ~color =
+|let spawn_random_exn ~rows ~cols ~color ~invalid_pos =
-|  let head = Position.random_pos ~rows ~cols ~invalid_pos:[] in
+|  let head = Position.random_pos ~rows ~cols ~invalid_pos in
    let head_exn = Option.value_exn head in
    { pos = [ head_exn ]; left_to_grow = 0; color }
  ;;
  
  let cell_background s pos =
    if List.mem (list_of_t s) pos ~equal:Position.equal then Some s.color else None
  ;;
  
  let head s = List.hd_exn s.pos
  
  let move s dir =
    let new_head = Position.step (head s) dir in
    let new_pos =
      let with_head = new_head :: s.pos in
      if Int.equal s.left_to_grow 0 then List.drop_last_exn with_head else with_head
    in

==== /src/snake.mli ====
-1,29 +1,34
  open! Core
  
  (** A [t] represents a snake, which keeps track of how much it
      has left to grow. *)
  type t [@@deriving sexp, equal]
  
  (** [list_of_t t] returns a list of [Position.t]s occupied by the snake. *)
  val list_of_t : t -> Position.t list
  
  (** [spawn_random_exn ~rows ~cols ~invalid_pos] creates a length-1 snake
      placed randomly on the left half ([col < cols/2]) of a rows*cols grid.
      The provided color will be used in calls to [cell_background]. *)
-|val spawn_random_exn : rows:int -> cols:int -> color:string -> t
+|val spawn_random_exn
+|  :  rows:int
+|  -> cols:int
+|  -> color:string
+|  -> invalid_pos:Position.t list
+|  -> t
  
  (** [cell_background t pos] computes the background of a cell at [pos], if
      that cell is occupied by t. Otherwise, it returns [None] *)
  val cell_background : t -> Position.t -> string option
  
  (** [move t dir] moves a snake 1 step in [dir]. It may or may not grow,
      depending on its internal state. *)
  val move : t -> Direction.t -> t
  
  (** [is_eatting_apple t] returns true iff the snake's head is overlapping
      with the provided [Apple.t].  *)
  val is_eatting_apple : t -> Apple.t -> bool
  
  (** [is_eatting_self t] returns true iff the snake's head is overlapping with any of
      the snake's body segments.  *)
  val is_eatting_self : t -> bool
