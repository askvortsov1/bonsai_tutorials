==== /src/app.ml ====
-12,80 +12,93
  }
  |}]
  
  let rows = 20
  let cols = 20
  
  let get_keydown_key evt =
    evt##.code
    |> Js_of_ocaml.Js.Optdef.to_option
    |> Option.value_exn
    |> Js_of_ocaml.Js.to_string
  ;;
  
  let component =
    let open Bonsai.Let_syntax in
    (* State *)
-|  let%sub player, player_inject =
+|  let%sub player1, player1_inject =
      Player_state.computation ~rows ~cols ~color:(`Name "green")
    in
-|  let%sub apple, apple_inject = Apple_state.computation ~rows ~cols in
+|  let%sub player2, player2_inject =
+|    Player_state.computation ~rows ~cols ~color:(`Name "blue")
+|  in
+|  let%sub apple1, apple1_inject = Apple_state.computation ~rows ~cols in
+|  let%sub apple2, apple2_inject = Apple_state.computation ~rows ~cols in
-|  let%sub snake_apple =
+|  let%sub game_elements =
-|    let%arr apple = apple
-|    and player = player in
-|    let apple_opt =
-|      match apple with
-|      | Playing apple -> Some apple
-|      | Not_started -> None
-|    in
-|    let snake_opt =
-|      match player with
-|      | Playing p | Game_over (p, _) -> Some p.snake
-|      | Not_started -> None
-|    in
-|    snake_opt, apple_opt
+|    let%arr player1 = player1
+|    and player2 = player2
+|    and apple1 = apple1
+|    and apple2 = apple2 in
+|    { Game_elements.snakes = Player_state.Model.snakes [ player1; player2 ]
+|    ; apples = Apple_state.Model.apples [ apple1; apple2 ]
+|    }
-|  in
-|  let%sub scheduler = Chain_incr_effects.component snake_apple in
+|  in
+|  let%sub scheduler = Chain_incr_effects.component game_elements in
    (* Tick logic *)
    let%sub () =
      let%sub clock_effect =
-|      let%arr player_inject = player_inject
-|      and apple_inject = apple_inject
+|      let%arr player1_inject = player1_inject
+|      and player2_inject = player2_inject
+|      and apple1_inject = apple1_inject
+|      and apple2_inject = apple2_inject
-|      and scheduler = scheduler in
-|      scheduler
-|        [ (fun (_s, a) -> player_inject (Move a))
+|      and scheduler = scheduler in
+|      scheduler
+|        [ (fun g -> player1_inject (Move g))
+|        ; (fun g -> player2_inject (Move g))
-|        ; (fun (s, _a) -> apple_inject (Tick s))
+|        ; (fun g -> apple1_inject (Tick g))
+|        ; (fun g -> apple2_inject (Tick g))
          ]
      in
      Bonsai.Clock.every [%here] (Time_ns.Span.of_sec 0.25) clock_effect
    in
    (* Reset logic *)
    let%sub reset_action =
-|    let%arr player_inject = player_inject
-|    and apple_inject = apple_inject
+|    let%arr player1_inject = player1_inject
+|    and player2_inject = player2_inject
+|    and apple1_inject = apple1_inject
+|    and apple2_inject = apple2_inject
-|    and scheduler = scheduler in
-|    scheduler
-|      [ (fun _ -> player_inject Restart); (fun (s, _a) -> apple_inject (Spawn s)) ]
+|    and scheduler = scheduler in
+|    scheduler
+|      [ (fun g -> player1_inject (Restart g))
+|      ; (fun g -> player2_inject (Restart g))
+|      ; (fun g -> apple1_inject (Spawn g))
+|      ; (fun g -> apple2_inject (Spawn g))
+|      ]
    in
    (* View component *)
-|  let%sub board = Board.component ~rows ~cols player apple in
+|  let%sub board = Board.component ~rows ~cols player1 player2 game_elements in
    let%arr board = board
-|  and player_inject = player_inject
+|  and player1_inject = player1_inject
+|  and player2_inject = player2_inject
    and reset_action = reset_action in
    let on_keydown evt =
      match get_keydown_key evt with
-|    | "KeyW" -> player_inject (Change_direction Up)
+|    | "KeyW" -> player1_inject (Change_direction Up)
-|    | "KeyS" -> player_inject (Change_direction Down)
+|    | "KeyS" -> player1_inject (Change_direction Down)
-|    | "KeyA" -> player_inject (Change_direction Left)
+|    | "KeyA" -> player1_inject (Change_direction Left)
-|    | "KeyD" -> player_inject (Change_direction Right)
+|    | "KeyD" -> player1_inject (Change_direction Right)
+|    | "ArrowUp" -> player2_inject (Change_direction Up)
+|    | "ArrowDown" -> player2_inject (Change_direction Down)
+|    | "ArrowLeft" -> player2_inject (Change_direction Left)
+|    | "ArrowRight" -> player2_inject (Change_direction Right)
      | _ -> Effect.Ignore
    in
    Vdom.(
      Node.div
        ~attr:
          (Attr.many
             [ Attr.on_keydown on_keydown
             ; Attr.on_click (fun _ -> reset_action)
             ; Attr.class_ Style.app
             ])
        [ board ])
  ;;

==== /src/apple_state.ml ====
-1,42 +1,46
  open! Core
  open! Bonsai_web
  
  module Model = struct
    type t =
      | Not_started
      | Playing of Apple.t
    [@@deriving sexp, equal]
+|
+|  let apples states =
+|    List.fold states ~init:[] ~f:(fun apples -> function
+|      | Playing apple -> apple :: apples
+|      | Not_started -> apples)
+|  ;;
  end
  
  module Action = struct
    type t =
-|    | Spawn of Snake.t option
+|    | Spawn of Game_elements.t
-|    | Tick of Snake.t option
+|    | Tick of Game_elements.t
    [@@deriving sexp]
  end
  
-|let spawn ~rows ~cols snake =
+|let spawn ~rows ~cols game_elements =
-|  let invalid_pos = Snake.list_of_t snake in
+|  let invalid_pos = Game_elements.occupied_pos game_elements in
    Model.Playing (Apple.spawn_random_exn ~rows ~cols ~invalid_pos)
  ;;
  
  let apply_action ~rows ~cols ~inject:_ ~schedule_event:_ model action =
    match action, model with
-|  | Action.Spawn None, _ ->
-|    raise_s [%message "Invalid state: snake should be spawned before apple."]
-|  | Action.Spawn (Some snake), _ -> spawn ~rows ~cols snake
-|  | Tick None, Model.Playing _ ->
-|    raise_s [%message "Invalid state: apple initialized but not snake."]
-|  | Tick (Some snake), Model.Playing apple ->
-|    if Snake.is_eatting_apple snake apple then spawn ~rows ~cols snake else model
+|  | Action.Spawn game_elements, _ -> spawn ~rows ~cols game_elements
+|  | Tick game_elements, Model.Playing apple ->
+|    if List.exists game_elements.snakes ~f:(fun s -> Snake.is_eatting_apple s apple)
+|    then spawn ~rows ~cols game_elements
+|    else model
    | Tick _, Model.Not_started -> model
  ;;
  
  let computation ~rows ~cols =
    Bonsai.state_machine0
      [%here]
      (module Model)
      (module Action)
      ~default_model:Not_started
      ~apply_action:(apply_action ~rows ~cols)
  ;;

==== /src/apple_state.mli ====
-1,21 +1,27
  open! Core
  open! Bonsai_web
  
  module Model : sig
    type t =
      | Not_started
      | Playing of Apple.t
    [@@deriving sexp, equal]
+|
+|  (** [apples states] returns a list of [Apple.t]s  for each apple
+|    who's status isn't [Not_started].
+|    Intended to be used in the assembly of [Game_elements.t],
+|    but can't be located there to avoid circular dependencies. *)
+|  val apples : t list -> Apple.t list
  end
  
  module Action : sig
    type t =
-|    | Spawn of Snake.t option
+|    | Spawn of Game_elements.t
-|    | Tick of Snake.t option
+|    | Tick of Game_elements.t
    [@@deriving sexp]
  end
  
  val computation
    :  rows:int
    -> cols:int
    -> (Model.t * (Action.t -> unit Effect.t)) Computation.t

==== /src/board.ml ====
-56,45 +56,45
    in
    Vdom.(Node.div (Node.h3 [ Node.text label ] :: content))
  ;;
  
  let set_style_property key value =
    let open Js_of_ocaml in
    let priority = Js.undefined in
    let res =
      Dom_html.document##.documentElement##.style##setProperty
        (Js.string key)
        (Js.string value)
        priority
    in
    ignore res
  ;;
  
-|let component ~rows ~cols player apple =
+|let component ~rows ~cols player1 player2 (game_elements : Game_elements.t Value.t) =
    let open Bonsai.Let_syntax in
    (* TODO: use `Attr.css_var` instead. *)
    let on_activate =
      Ui_effect.of_sync_fun
        (fun () ->
          set_style_property "--grid-rows" (Int.to_string rows);
          set_style_property "--grid-cols" (Int.to_string cols))
        ()
      |> Value.return
    in
    let%sub () = Bonsai.Edge.lifecycle ~on_activate () in
-|  let%arr player = player
-|  and apple = apple in
+|  let%arr player1 = player1
+|  and player2 = player2
+|  and game_elements = game_elements in
-|  let cell_style_driver =
-|    match player, apple with
-|    | Player_state.Model.Not_started, _ | _, Apple_state.Model.Not_started ->
+|  let cell_style_driver =
-|      merge_cell_style_drivers ~snakes:[] ~apples:[]
-|    | Playing data, Playing apple | Game_over (data, _), Playing apple ->
-|      merge_cell_style_drivers ~snakes:[ data.snake ] ~apples:[ apple ]
+|    merge_cell_style_drivers ~snakes:game_elements.snakes ~apples:game_elements.apples
    in
    Vdom.(
      Node.div
        [ Node.h1 [ Node.text "Snake Game" ]
        ; Node.p [ Node.text "Click anywhere to reset." ]
-|      ; view_score_status ~label:"Results" player
+|      ; Node.div
+|          [ view_score_status ~label:"Player 1" player1
+|          ; view_score_status ~label:"Player 2" player2
+|          ]
        ; view_game_grid rows cols cell_style_driver
        ])
  ;;

==== /src/board.mli ====
-1,9 +1,10
  open! Core
  open! Bonsai_web
  
  val component
    :  rows:int
    -> cols:int
    -> Player_state.Model.t Value.t
-|  -> Apple_state.Model.t Value.t
+|  -> Player_state.Model.t Value.t
+|  -> Game_elements.t Value.t
    -> Vdom.Node.t Computation.t

==== /src/game_elements.ml ====
-1,0 +1,13
+|open! Core
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : Apple.t list
+|  }
+|[@@deriving sexp]
+|
+|let occupied_pos t =
+|  let snake_pos = t.snakes |> List.map ~f:Snake.list_of_t |> List.join in
+|  let apple_pos = t.apples |> List.map ~f:Apple.list_of_t |> List.join in
+|  snake_pos @ apple_pos
+|;;

==== /src/game_elements.mli ====
-1,0 +1,9
+|open! Core
+|
+|type t =
+|  { snakes : Snake.t list
+|  ; apples : Apple.t list
+|  }
+|[@@deriving sexp]
+|
+|val occupied_pos : t -> Position.t list

==== /src/player_state.ml ====
-10,72 +10,80
    end
  
    module Data = struct
      type t =
        { score : int
        ; snake : Snake.t
        ; direction : Direction.t
        }
      [@@deriving sexp, equal, fields]
    end
  
    type t =
      | Not_started
      | Playing of Data.t
      | Game_over of (Data.t * End_reason.t)
    [@@deriving sexp, equal, variants]
+|
+|  let snakes states =
+|    List.fold states ~init:[] ~f:(fun snakes -> function
+|      | Playing data | Game_over (data, _) -> data.snake :: snakes
+|      | Not_started -> snakes)
+|  ;;
  end
  
  module Action = struct
    type t =
-|    | Restart
+|    | Restart of Game_elements.t
-|    | Move of Apple.t option
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
    [@@deriving sexp]
  end
  
  let ate_apple_score = 1
  
  let apply_action
    ~rows
    ~cols
    ~color
    ~inject:_
    ~schedule_event:_
    (model : Model.t)
    (action : Action.t)
    =
    match action, model with
-|  | Restart, _ ->
+|  | Restart game_elements, _ ->
+|    let invalid_pos = Game_elements.occupied_pos game_elements in
-|    let snake = Snake.spawn_random_exn ~rows ~cols:(cols / 2) ~invalid_pos:[] ~color in
+|    let snake = Snake.spawn_random_exn ~rows ~cols:(cols / 2) ~color ~invalid_pos in
-|    Model.Playing { score = 0; snake; direction = Right }
-|  | Move None, Playing _ ->
-|    raise_s [%message "Invalid state: snake initialized but not apple."]
-|  | Move (Some apple), Playing data ->
+|    Model.Playing { score = 0; snake; direction = Right }
+|  | Move game_elements, Playing data ->
      let snake = Snake.move data.snake data.direction in
      if Snake.is_eatting_self snake
      then Game_over (data, Ate_self)
      else if Snake.is_out_of_bounds ~rows ~cols snake
      then Game_over (data, Out_of_bounds)
-|    else if Snake.is_eatting_apple snake apple
-|    then
+|    else (
+|      let num_apples_eatten =
+|        game_elements.apples
+|        |> List.filter ~f:(Snake.is_eatting_apple snake)
+|        |> List.length
+|      in
-|      Playing
-|        { direction = data.direction
-|        ; snake = Snake.grow_eventually ~by:1 snake
+|      Playing
+|        { direction = data.direction
+|        ; snake = Snake.grow_eventually ~by:num_apples_eatten snake
-|        ; score = data.score + ate_apple_score
-|        }
-|    else Playing { direction = data.direction; snake; score = data.score }
+|        ; score = data.score + (num_apples_eatten * ate_apple_score)
+|        })
    | Change_direction dir, Playing data -> Playing { data with direction = dir }
    | Move _, Not_started
    | Move _, Game_over _
    | Change_direction _, Not_started
    | Change_direction _, Game_over _ -> model
  ;;
  
  let computation ~rows ~cols ~color =
    Bonsai.state_machine0
      [%here]
      (module Model)
      (module Action)
      ~default_model:Not_started
      ~apply_action:(apply_action ~rows ~cols ~color)
  ;;

==== /src/player_state.mli ====
-10,30 +10,35
    end
  
    module Data : sig
      type t =
        { score : int
        ; snake : Snake.t
        ; direction : Direction.t
        }
      [@@deriving sexp, equal, fields]
    end
  
    type t =
      | Not_started
      | Playing of Data.t
      | Game_over of (Data.t * End_reason.t)
    [@@deriving sexp, equal, variants]
+|
+|  (** [snakes ps] returns a list of snakes for each player who's status isn't
+|      [Not_started]. Intended to be used in the assembly of [Game_elements.t],
+|      but can't be located there to avoid circular dependencies. *)
+|  val snakes : t list -> Snake.t list
  end
  
  module Action : sig
    type t =
-|    | Restart
+|    | Restart of Game_elements.t
-|    | Move of Apple.t option
+|    | Move of Game_elements.t
      | Change_direction of Direction.t
  end
  
  val computation
    :  rows:int
    -> cols:int
    -> color:Css_gen.Color.t
    -> (Model.t * (Action.t -> unit Effect.t)) Computation.t
