==== /src/app.ml ====
-1,11 +1,71
  open! Core
  open! Bonsai_web
  
+|module Style =
+|[%css.raw
+|{|
+|html,body{min-height:100%; height:100%;}
+|
+|.app {
+|  width: 100%;
+|  height: 100%;
+|}
+||}]
+|
  let rows = 20
  let cols = 20
  
-|let component =
-|  let snake = Snake.spawn_random ~rows ~cols ~color:"green" in
-|  let apple = Apple.spawn_random ~rows ~cols ~invalid_pos:(Snake.list_of_t snake) in
-|  Board.component ~rows ~cols (Value.return snake) (Value.return apple)
+|let get_keydown_key evt =
+|  evt##.code
+|  |> Js_of_ocaml.Js.Optdef.to_option
+|  |> Option.value_exn
+|  |> Js_of_ocaml.Js.to_string
+|;;
+|
+|let component =
+|  let open Bonsai.Let_syntax in
+|  (* State *)
+|  let%sub player, player_inject = Player.computation ~rows ~cols ~color:"green" in
+|  let%sub apple, apple_inject = Apple.computation ~rows ~cols in
+|  (* Tick logic *)
+|  let%sub () =
+|    let%sub clock_effect =
+|      let%arr player_inject = player_inject
+|      and apple = apple
+|      and apple_inject = apple_inject in
+|      player_inject (Move (apple, apple_inject))
+|    in
+|    Bonsai.Clock.every [%here] (Time_ns.Span.of_sec 0.25) clock_effect
+|  in
+|  (* Reset logic *)
+|  let%sub reset_action =
+|    let%arr player_inject = player_inject
+|    and apple_inject = apple_inject
+|    and player = player
+|    and apple = apple in
+|    let invalid_pos = Player.snake_pos player @ Apple.list_of_t apple in
+|    Effect.Many [ player_inject Restart; apple_inject (Spawn invalid_pos) ]
+|  in
+|  (* View component *)
+|  let%sub board = Board.component ~rows ~cols player apple in
+|  let%arr board = board
+|  and player_inject = player_inject
+|  and reset_action = reset_action in
+|  let on_keydown evt =
+|    match get_keydown_key evt with
+|    | "KeyW" -> player_inject (Change_direction Up)
+|    | "KeyS" -> player_inject (Change_direction Down)
+|    | "KeyA" -> player_inject (Change_direction Left)
+|    | "KeyD" -> player_inject (Change_direction Right)
+|    | _ -> Effect.Ignore
+|  in
+|  Vdom.(
+|    Node.div
+|      ~attr:
+|        (Attr.many
+|           [ Attr.on_keydown on_keydown
+|           ; Attr.on_click (fun _ -> reset_action)
+|           ; Attr.class_ Style.app
+|           ])
+|      [ board ])
  ;;

==== /src/apple.ml ====
-2,16 +2,41
  open! Bonsai_web
  
  type t = Position.t option [@@deriving sexp, equal]
  
  let list_of_t t =
    match t with
    | Some pos -> [ pos ]
    | None -> []
  ;;
  
  let spawn_random ~rows ~cols ~invalid_pos = Position.random_pos ~rows ~cols ~invalid_pos
  let is_eatten a s = Option.mem a (Snake.head s) ~equal:Position.equal
  
  let cell_background a pos =
    if Option.mem a pos ~equal:Position.equal then Some "red" else None
  ;;
+|
+|module Model = struct
+|  type t = Position.t option [@@deriving sexp, equal]
+|end
+|
+|module Action = struct
+|  type t =
+|    | Spawn of Position.t list
+|    | Eatten of Position.t list
+|  [@@deriving sexp]
+|end
+|
+|let apply_action ~rows ~cols ~inject:_ ~schedule_event:_ _model action =
+|  match action with
+|  | Action.Eatten invalid_pos | Spawn invalid_pos -> spawn_random ~rows ~cols ~invalid_pos
+|;;
+|
+|let computation ~rows ~cols =
+|  Bonsai.state_machine0
+|    [%here]
+|    (module Model)
+|    (module Action)
+|    ~default_model:None
+|    ~apply_action:(apply_action ~rows ~cols)
+|;;

==== /src/apple.mli ====
-6,16 +6,25
  type t = Position.t option [@@deriving sexp]
  
  (** [list_of_t t] returns a list of positions occupied by the apple. *)
  val list_of_t : t -> Position.t list
  
  (** [spawn_random ~rows ~cols ~invalid_pos] creates an apple placed randomly
      on a rows*cols grid; excluding cells in ~invalid_pos. *)
  val spawn_random : rows:int -> cols:int -> invalid_pos:Position.t list -> t
  
  (** [is_eatten t s] returns true iff the apple is at the same position as the given
      snake's head.  *)
  val is_eatten : t -> Snake.t -> bool
  
  (** [cell_background t pos] computes the background of a cell at [pos], if
      that cell is occupied by t. Otherwise, it returns [None] *)
  val cell_background : t -> Position.t -> string option
+|
+|module Action : sig
+|  type t =
+|    | Spawn of Position.t list
+|    | Eatten of Position.t list
+|  [@@deriving sexp]
+|end
+|
+|val computation : rows:int -> cols:int -> (t * (Action.t -> unit Effect.t)) Computation.t

==== /src/board.ml ====
-24,63 +24,84
      List.init rows ~f:(fun row ->
        List.init cols ~f:(fun col ->
          let pos = { Position.row; col } in
          let background_str = cell_bg_driver pos in
          let css = Css_gen.create ~field:"background" ~value:background_str in
          Vdom.(
            Node.div
              ~attr:(Attr.many [ Attr.style css; Attr.classes [ Style.grid_cell ] ])
              [])))
      |> List.concat
    in
    Vdom.(Node.div ~attr:(Attr.class_ Style.grid) cells)
  ;;
  
  let view_instructions = Vdom.(Node.p [ Node.text "Click anywhere to reset." ])
  
+|let view_score_status ~label player =
+|  let content =
+|    let open Vdom.Node in
+|    let score_text score = p [ textf "Score: %d" score ] in
+|    match player with
+|    | Player.Not_started -> [ p [ text "Click to start!" ] ]
+|    | Playing data -> [ score_text data.score ]
+|    | Game_over (data, Out_of_bounds) ->
+|      [ p [ text "Game over... Out of bounds!" ]; score_text data.score ]
+|    | Game_over (data, Ate_self) ->
+|      [ p [ text "Game over... Ate self!" ]; score_text data.score ]
+|  in
+|  Vdom.(Node.div (Node.h3 [ Node.text label ] :: content))
+|;;
+|
  let merge_cell_bg_drivers ~snakes ~apples =
    let drivers =
      List.join
        [ List.map snakes ~f:Snake.cell_background
        ; List.map apples ~f:Apple.cell_background
        ]
    in
    fun pos ->
      match List.find_map drivers ~f:(fun driver -> driver pos) with
      | Some x -> x
      | None -> "white"
  ;;
  
  let set_style_property key value =
    let open Js_of_ocaml in
    let priority = Js.undefined in
    let res =
      Dom_html.document##.documentElement##.style##setProperty
        (Js.string key)
        (Js.string value)
        priority
    in
    ignore res
  ;;
  
-|let component ~rows ~cols snake apple =
+|let component ~rows ~cols player apple =
    let open Bonsai.Let_syntax in
    (* TODO: use `Attr.css_var` instead. *)
    let on_activate =
      Ui_effect.of_sync_fun
        (fun () ->
          set_style_property "--grid-rows" (Int.to_string rows);
          set_style_property "--grid-cols" (Int.to_string cols))
        ()
      |> Value.return
    in
    let%sub () = Bonsai.Edge.lifecycle ~on_activate () in
-|  let%arr snake = snake
+|  let%arr player = player
    and apple = apple in
-|  let cell_bg_driver = merge_cell_bg_drivers ~snakes:[ snake ] ~apples:[ apple ] in
+|  let cell_bg_driver =
+|    match player with
+|    | Player.Not_started -> merge_cell_bg_drivers ~snakes:[] ~apples:[]
+|    | Playing data | Game_over (data, _) ->
+|      merge_cell_bg_drivers ~snakes:[ data.snake ] ~apples:[ apple ]
+|  in
    Vdom.(
      Node.div
        [ Node.h1 [ Node.text "Snake Game" ]
        ; view_instructions
+|      ; view_score_status ~label:"Results" player
        ; view_board rows cols cell_bg_driver
        ])
  ;;

==== /src/board.mli ====
-1,9 +1,9
  open! Core
  open! Bonsai_web
  
  val component
    :  rows:int
    -> cols:int
-|  -> Snake.t Value.t
+|  -> Player.t Value.t
    -> Apple.t Value.t
    -> Vdom.Node.t Computation.t

==== /src/player.ml ====
-1,0 +1,88
+|open! Core
+|open! Bonsai
+|
+|module Model = struct
+|  module End_reason = struct
+|    type t =
+|      | Ate_self
+|      | Out_of_bounds
+|    [@@deriving sexp, equal]
+|  end
+|
+|  module Data = struct
+|    type t =
+|      { score : int
+|      ; snake : Snake.t
+|      ; direction : Direction.t
+|      }
+|    [@@deriving sexp, equal, fields]
+|  end
+|
+|  type t =
+|    | Not_started
+|    | Playing of Data.t
+|    | Game_over of (Data.t * End_reason.t)
+|  [@@deriving sexp, equal, variants]
+|end
+|
+|include Model
+|
+|let snake_pos = function
+|  | Playing data | Game_over (data, _) -> Snake.list_of_t data.snake
+|  | Not_started -> []
+|;;
+|
+|module Action = struct
+|  type t =
+|    | Restart
+|    | Move of (Apple.t * (Apple.Action.t -> unit Effect.t))
+|    | Change_direction of Direction.t
+|  [@@deriving sexp]
+|end
+|
+|let ate_apple_score = 1
+|
+|let apply_action
+|  ~rows
+|  ~cols
+|  ~color
+|  ~inject:_
+|  ~schedule_event
+|  (model : Model.t)
+|  (action : Action.t)
+|  =
+|  match action, model with
+|  | Restart, _ ->
+|    let snake = Snake.spawn_random ~rows ~cols:(cols / 2) ~color in
+|    Playing { score = 0; snake; direction = Right }
+|  | Move (apple, apple_inject), Playing data ->
+|    let snake = Snake.move data.snake data.direction in
+|    if Snake.is_eatting_self snake
+|    then Game_over (data, Ate_self)
+|    else if Snake.is_out_of_bounds ~rows ~cols snake
+|    then Game_over (data, Out_of_bounds)
+|    else if Apple.is_eatten apple snake
+|    then (
+|      let invalid_pos = Snake.list_of_t snake @ Apple.list_of_t apple in
+|      let () = schedule_event (apple_inject (Apple.Action.Eatten invalid_pos)) in
+|      Playing
+|        { direction = data.direction
+|        ; snake = Snake.grow_eventually ~by:1 snake
+|        ; score = data.score + ate_apple_score
+|        })
+|    else Playing { direction = data.direction; snake; score = data.score }
+|  | Change_direction dir, Playing data -> Playing { data with direction = dir }
+|  | Move _, Not_started
+|  | Move _, Game_over _
+|  | Change_direction _, Not_started
+|  | Change_direction _, Game_over _ -> model
+|;;
+|
+|let computation ~rows ~cols ~color =
+|  Bonsai.state_machine0
+|    [%here]
+|    (module Model)
+|    (module Action)
+|    ~default_model:Not_started
+|    ~apply_action:(apply_action ~rows ~cols ~color)
+|;;

==== /src/player.mli ====
-1,0 +1,39
+|open! Core
+|open! Bonsai
+|
+|module End_reason : sig
+|  type t =
+|    | Ate_self
+|    | Out_of_bounds
+|  [@@deriving sexp, equal]
+|end
+|
+|module Data : sig
+|  type t =
+|    { score : int
+|    ; snake : Snake.t
+|    ; direction : Direction.t
+|    }
+|  [@@deriving sexp, equal, fields]
+|end
+|
+|type t =
+|  | Not_started
+|  | Playing of Data.t
+|  | Game_over of (Data.t * End_reason.t)
+|[@@deriving sexp, equal, variants]
+|
+|val snake_pos : t -> Position.t list
+|
+|module Action : sig
+|  type t =
+|    | Restart
+|    | Move of (Apple.t * (Apple.Action.t -> unit Effect.t))
+|    | Change_direction of Direction.t
+|end
+|
+|val computation
+|  :  rows:int
+|  -> cols:int
+|  -> color:string
+|  -> (t * (Action.t -> unit Effect.t)) Computation.t
