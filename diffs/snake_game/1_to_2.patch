==== /src/app.ml ====
-1,11 +1,75
  open! Core
  open! Bonsai_web
  
+|module Style =
+|[%css.raw
+|{|
+|html,body{min-height:100%; height:100%;}
+|
+|.app {
+|  width: 100%;
+|  height: 100%;
+|}
+||}]
+|
  let rows = 20
  let cols = 20
  
-|let component =
-|  let snake = Snake.spawn_random_exn ~rows ~cols ~color:"green" in
-|  let apple = Apple.spawn_random_exn ~rows ~cols ~invalid_pos:(Snake.list_of_t snake) in
-|  Board.component ~rows ~cols (Value.return snake) (Value.return apple)
+|let get_keydown_key evt =
+|  evt##.code
+|  |> Js_of_ocaml.Js.Optdef.to_option
+|  |> Option.value_exn
+|  |> Js_of_ocaml.Js.to_string
+|;;
+|
+|let component =
+|  let open Bonsai.Let_syntax in
+|  (* State *)
+|  let%sub player, player_inject = Player_state.computation ~rows ~cols ~color:"green" in
+|  let%sub apple, apple_inject = Apple_state.computation ~rows ~cols in
+|  (* Tick logic *)
+|  let%sub () =
+|    let%sub clock_effect =
+|      let%arr player_inject = player_inject
+|      and apple = apple
+|      and apple_inject = apple_inject in
+|      match apple with
+|      | Playing apple -> player_inject (Move (apple, apple_inject))
+|      | Not_started -> Effect.Ignore
+|    in
+|    Bonsai.Clock.every [%here] (Time_ns.Span.of_sec 0.25) clock_effect
+|  in
+|  (* Reset logic *)
+|  let%sub reset_action =
+|    let%arr player_inject = player_inject
+|    and apple_inject = apple_inject
+|    and player = player
+|    and apple = apple in
+|    let invalid_pos =
+|      Player_state.Model.snake_pos player @ Apple_state.Model.apple_pos apple
+|    in
+|    Effect.Many [ player_inject Restart; apple_inject (Spawn invalid_pos) ]
+|  in
+|  (* View component *)
+|  let%sub board = Board.component ~rows ~cols player apple in
+|  let%arr board = board
+|  and player_inject = player_inject
+|  and reset_action = reset_action in
+|  let on_keydown evt =
+|    match get_keydown_key evt with
+|    | "KeyW" -> player_inject (Change_direction Up)
+|    | "KeyS" -> player_inject (Change_direction Down)
+|    | "KeyA" -> player_inject (Change_direction Left)
+|    | "KeyD" -> player_inject (Change_direction Right)
+|    | _ -> Effect.Ignore
+|  in
+|  Vdom.(
+|    Node.div
+|      ~attr:
+|        (Attr.many
+|           [ Attr.on_keydown on_keydown
+|           ; Attr.on_click (fun _ -> reset_action)
+|           ; Attr.class_ Style.app
+|           ])
+|      [ board ])
  ;;

==== /src/apple_state.ml ====
-1,0 +1,37
+|open! Core
+|open! Bonsai_web
+|
+|module Model = struct
+|  type t =
+|    | Not_started
+|    | Playing of Apple.t
+|  [@@deriving sexp, equal]
+|
+|  let apple_pos t =
+|    match t with
+|    | Playing a -> Apple.list_of_t a
+|    | Not_started -> []
+|  ;;
+|end
+|
+|module Action = struct
+|  type t =
+|    | Spawn of Position.t list
+|    | Eatten of Position.t list
+|  [@@deriving sexp]
+|end
+|
+|let apply_action ~rows ~cols ~inject:_ ~schedule_event:_ _model action =
+|  match action with
+|  | Action.Eatten invalid_pos | Spawn invalid_pos ->
+|    Model.Playing (Apple.spawn_random_exn ~rows ~cols ~invalid_pos)
+|;;
+|
+|let computation ~rows ~cols =
+|  Bonsai.state_machine0
+|    [%here]
+|    (module Model)
+|    (module Action)
+|    ~default_model:Not_started
+|    ~apply_action:(apply_action ~rows ~cols)
+|;;

==== /src/apple_state.mli ====
-1,0 +1,23
+|open! Core
+|open! Bonsai_web
+|
+|module Model : sig
+|  type t =
+|    | Not_started
+|    | Playing of Apple.t
+|  [@@deriving sexp, equal]
+|
+|  val apple_pos : t -> Position.t list
+|end
+|
+|module Action : sig
+|  type t =
+|    | Spawn of Position.t list
+|    | Eatten of Position.t list
+|  [@@deriving sexp]
+|end
+|
+|val computation
+|  :  rows:int
+|  -> cols:int
+|  -> (Model.t * (Action.t -> unit Effect.t)) Computation.t

==== /src/board.ml ====
-24,63 +24,85
      List.init rows ~f:(fun row ->
        List.init cols ~f:(fun col ->
          let pos = { Position.row; col } in
          let background_str = cell_bg_driver pos in
          let css = Css_gen.create ~field:"background" ~value:background_str in
          Vdom.(
            Node.div
              ~attr:(Attr.many [ Attr.style css; Attr.classes [ Style.grid_cell ] ])
              [])))
      |> List.concat
    in
    Vdom.(Node.div ~attr:(Attr.class_ Style.grid) cells)
  ;;
  
  let view_instructions = Vdom.(Node.p [ Node.text "Click anywhere to reset." ])
  
+|let view_score_status ~label player =
+|  let content =
+|    let open Vdom.Node in
+|    let score_text score = p [ textf "Score: %d" score ] in
+|    match player with
+|    | Player_state.Model.Not_started -> [ p [ text "Click to start!" ] ]
+|    | Playing data -> [ score_text data.score ]
+|    | Game_over (data, Out_of_bounds) ->
+|      [ p [ text "Game over... Out of bounds!" ]; score_text data.score ]
+|    | Game_over (data, Ate_self) ->
+|      [ p [ text "Game over... Ate self!" ]; score_text data.score ]
+|  in
+|  Vdom.(Node.div (Node.h3 [ Node.text label ] :: content))
+|;;
+|
  let merge_cell_bg_drivers ~snakes ~apples =
    let drivers =
      List.join
        [ List.map snakes ~f:Snake.cell_background
        ; List.map apples ~f:Apple.cell_background
        ]
    in
    fun pos ->
      match List.find_map drivers ~f:(fun driver -> driver pos) with
      | Some x -> x
      | None -> "white"
  ;;
  
  let set_style_property key value =
    let open Js_of_ocaml in
    let priority = Js.undefined in
    let res =
      Dom_html.document##.documentElement##.style##setProperty
        (Js.string key)
        (Js.string value)
        priority
    in
    ignore res
  ;;
  
-|let component ~rows ~cols snake apple =
+|let component ~rows ~cols player apple =
    let open Bonsai.Let_syntax in
    (* TODO: use `Attr.css_var` instead. *)
    let on_activate =
      Ui_effect.of_sync_fun
        (fun () ->
          set_style_property "--grid-rows" (Int.to_string rows);
          set_style_property "--grid-cols" (Int.to_string cols))
        ()
      |> Value.return
    in
    let%sub () = Bonsai.Edge.lifecycle ~on_activate () in
-|  let%arr snake = snake
+|  let%arr player = player
    and apple = apple in
-|  let cell_bg_driver = merge_cell_bg_drivers ~snakes:[ snake ] ~apples:[ apple ] in
+|  let cell_bg_driver =
+|    match player, apple with
+|    | Player_state.Model.Not_started, _ | _, Apple_state.Model.Not_started ->
+|      merge_cell_bg_drivers ~snakes:[] ~apples:[]
+|    | Playing data, Playing apple | Game_over (data, _), Playing apple ->
+|      merge_cell_bg_drivers ~snakes:[ data.snake ] ~apples:[ apple ]
+|  in
    Vdom.(
      Node.div
        [ Node.h1 [ Node.text "Snake Game" ]
        ; view_instructions
+|      ; view_score_status ~label:"Results" player
        ; view_board rows cols cell_bg_driver
        ])
  ;;

==== /src/board.mli ====
-1,9 +1,9
  open! Core
  open! Bonsai_web
  
  val component
    :  rows:int
    -> cols:int
-|  -> Snake.t Value.t
+|  -> Player_state.Model.t Value.t
-|  -> Apple.t Value.t
+|  -> Apple_state.Model.t Value.t
    -> Vdom.Node.t Computation.t

==== /src/player_state.ml ====
-1,0 +1,86
+|open! Core
+|open! Bonsai
+|
+|module Model = struct
+|  module End_reason = struct
+|    type t =
+|      | Ate_self
+|      | Out_of_bounds
+|    [@@deriving sexp, equal]
+|  end
+|
+|  module Data = struct
+|    type t =
+|      { score : int
+|      ; snake : Snake.t
+|      ; direction : Direction.t
+|      }
+|    [@@deriving sexp, equal, fields]
+|  end
+|
+|  type t =
+|    | Not_started
+|    | Playing of Data.t
+|    | Game_over of (Data.t * End_reason.t)
+|  [@@deriving sexp, equal, variants]
+|
+|  let snake_pos = function
+|    | Playing data | Game_over (data, _) -> Snake.list_of_t data.snake
+|    | Not_started -> []
+|  ;;
+|end
+|
+|module Action = struct
+|  type t =
+|    | Restart
+|    | Move of (Apple.t * (Apple_state.Action.t -> unit Effect.t))
+|    | Change_direction of Direction.t
+|  [@@deriving sexp]
+|end
+|
+|let ate_apple_score = 1
+|
+|let apply_action
+|  ~rows
+|  ~cols
+|  ~color
+|  ~inject:_
+|  ~schedule_event
+|  (model : Model.t)
+|  (action : Action.t)
+|  =
+|  match action, model with
+|  | Restart, _ ->
+|    let snake = Snake.spawn_random_exn ~rows ~cols:(cols / 2) ~color in
+|    Model.Playing { score = 0; snake; direction = Right }
+|  | Move (apple, apple_inject), Playing data ->
+|    let snake = Snake.move data.snake data.direction in
+|    if Snake.is_eatting_self snake
+|    then Game_over (data, Ate_self)
+|    else if Snake.is_out_of_bounds ~rows ~cols snake
+|    then Game_over (data, Out_of_bounds)
+|    else if Snake.is_eatting_apple snake apple
+|    then (
+|      let invalid_pos = Snake.list_of_t snake @ Apple.list_of_t apple in
+|      let () = schedule_event (apple_inject (Apple_state.Action.Eatten invalid_pos)) in
+|      Playing
+|        { direction = data.direction
+|        ; snake = Snake.grow_eventually ~by:1 snake
+|        ; score = data.score + ate_apple_score
+|        })
+|    else Playing { direction = data.direction; snake; score = data.score }
+|  | Change_direction dir, Playing data -> Playing { data with direction = dir }
+|  | Move _, Not_started
+|  | Move _, Game_over _
+|  | Change_direction _, Not_started
+|  | Change_direction _, Game_over _ -> model
+|;;
+|
+|let computation ~rows ~cols ~color =
+|  Bonsai.state_machine0
+|    [%here]
+|    (module Model)
+|    (module Action)
+|    ~default_model:Not_started
+|    ~apply_action:(apply_action ~rows ~cols ~color)
+|;;

==== /src/player_state.mli ====
-1,0 +1,41
+|open! Core
+|open! Bonsai
+|
+|module Model : sig
+|  module End_reason : sig
+|    type t =
+|      | Ate_self
+|      | Out_of_bounds
+|    [@@deriving sexp, equal]
+|  end
+|
+|  module Data : sig
+|    type t =
+|      { score : int
+|      ; snake : Snake.t
+|      ; direction : Direction.t
+|      }
+|    [@@deriving sexp, equal, fields]
+|  end
+|
+|  type t =
+|    | Not_started
+|    | Playing of Data.t
+|    | Game_over of (Data.t * End_reason.t)
+|  [@@deriving sexp, equal, variants]
+|
+|  val snake_pos : t -> Position.t list
+|end
+|
+|module Action : sig
+|  type t =
+|    | Restart
+|    | Move of (Apple.t * (Apple_state.Action.t -> unit Effect.t))
+|    | Change_direction of Direction.t
+|end
+|
+|val computation
+|  :  rows:int
+|  -> cols:int
+|  -> color:string
+|  -> (Model.t * (Action.t -> unit Effect.t)) Computation.t

==== /src/snake.ml ====
-5,16 +5,43
    ; left_to_grow : int
    ; color : string
    }
  [@@deriving sexp, equal]
  
  let list_of_t s = s.pos
  
  let spawn_random_exn ~rows ~cols ~color =
    let head = Position.random_pos ~rows ~cols ~invalid_pos:[] in
    let head_exn = Option.value_exn head in
    { pos = [ head_exn ]; left_to_grow = 0; color }
  ;;
  
  let cell_background s pos =
    if List.mem (list_of_t s) pos ~equal:Position.equal then Some s.color else None
  ;;
+|
+|let head s = List.hd_exn s.pos
+|
+|let move s dir =
+|  let new_head = Position.step (head s) dir in
+|  let new_pos =
+|    let with_head = new_head :: s.pos in
+|    if Int.equal s.left_to_grow 0 then List.drop_last_exn with_head else with_head
+|  in
+|  let left_to_grow = Int.max 0 (s.left_to_grow - 1) in
+|  { s with left_to_grow; pos = new_pos }
+|;;
+|
+|let grow_eventually ~by s = { s with left_to_grow = s.left_to_grow + by }
+|
+|let is_out_of_bounds ~rows ~cols s =
+|  let { Position.row; col } = head s in
+|  row < 0 || row >= rows || col < 0 || col >= cols
+|;;
+|
+|let is_eatting_apple s a = List.exists (Apple.list_of_t a) ~f:(Position.equal (head s))
+|
+|let is_eatting_self s =
+|  match list_of_t s with
+|  | head :: tail -> List.mem tail head ~equal:Position.equal
+|  | [] -> false (* This should never happen. *)
+|;;

==== /src/snake.mli ====
-2,16 +2,36
  
  (** A [t] represents a snake, which keeps track of how much it
      has left to grow. *)
  type t [@@deriving sexp, equal]
  
  (** [list_of_t t] returns a list of [Position.t]s occupied by the snake. *)
  val list_of_t : t -> Position.t list
  
  (** [spawn_random_exn ~rows ~cols ~invalid_pos] creates a length-1 snake
      placed randomly on the left half ([col < cols/2]) of a rows*cols grid.
      The provided color will be used in calls to [cell_background]. *)
  val spawn_random_exn : rows:int -> cols:int -> color:string -> t
  
  (** [cell_background t pos] computes the background of a cell at [pos], if
      that cell is occupied by t. Otherwise, it returns [None] *)
  val cell_background : t -> Position.t -> string option
+|
+|(** [move t dir] moves a snake 1 step in [dir]. It may or may not grow,
+|    depending on its internal state. *)
+|val move : t -> Direction.t -> t
+|
+|(** [is_eatting_apple t] returns true iff the snake's head is overlapping
+|    with the provided [Apple.t].  *)
+|val is_eatting_apple : t -> Apple.t -> bool
+|
+|(** [is_eatting_self t] returns true iff the snake's head is overlapping with any of
+|    the snake's body segments.  *)
+|val is_eatting_self : t -> bool
+|
+|(** [is_out_of_bounds ~rows ~cols t] returns true iff the snake's head has gone
+|    outside of the [rows]*[cols] grid. *)
+|val is_out_of_bounds : rows:int -> cols:int -> t -> bool
+|
+|(** [grow_eventually ~by] updates a snake's internal state to grow 1 cell
+|    for the next [by] times [move] is called. *)
+|val grow_eventually : by:int -> t -> t
